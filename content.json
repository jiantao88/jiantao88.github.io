[{"title":"Android MVVM框架","date":"2017-03-25T04:44:41.000Z","path":"2017/03/25/Android MVVM框架/","text":"##一：android 分层框架概述目前项目中因为Controller(Activity)和View,Model没有实现解耦，造成Activity既要负责处理业务逻辑，又要负责UI显示，数据绑定，所以造成Activity里代码过多，逻辑不清楚，对代码的可读性，可维护性不是很好，所以采用一些分层模式，可以更为有效的对业务逻辑层，UI显示层，数据层进行拆分，集中分层模式有：使用的最多的是MVC和MVP。其中MVC出现与上世纪70年代，在三十多年的工程实践中，MVC充分证明了它的成功，同时在漫长的时间中演变出了许多变种，其中也包括MVP.MVC和MVP最大的差别在与控制层对于整个框架的控制力上。而MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力，三者之间的差别如下： ##二：android MVVM框架实现 RobobindingAndroid平台上有一些比较好的MVVM框架，其中用的比较多的是RoboBinding,Robobinding有如下特点： 为了精简框架，RoboBinding移除了大量不必要的代码，比如addXXListener()，findViewById()等。可以将难以测试的Android代码转换为普通的JUnit测试。提供对象类型Cursor来替换 - 关系类型Cursor，因为我们已经习惯于操作对象 。可以很容易的为任何自定义组件，第三方组件或Android widget编写属性绑定实现，简化代码，使项目易于维护。 Robobiding 简单使用示例：View层(对应android xml文件) 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://robobinding.org/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;org.robobinding.androidmvvm.MainActivity&quot; tools:ignore=&quot;MissingPrefix&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; bind:text=&quot;&#123;hello&#125;&quot;/&gt; //单向绑定，修改Model属性时，会自动反映到视图中（需要实体中提供相应的getHello(),setHello()方法）。 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Name:&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; bind:text=&quot;$&#123;name&#125;&quot;/&gt; //双向绑定，修改model属性时，会自动反映到视图中；反过来，修改视图内容，也会自动更改Model的相关属性。 &lt;/LinearLayout&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Say Hello&quot; bind:onClick=&quot;sayHello&quot;/&gt;&lt;/LinearLayout&gt; Model层：PresentationModel() 1234567891011121314151617181920212223public class PresentationModel implements HasPresentationModelChangeSupport &#123; private PresentationModelChangeSupport changeSupport; private String name; public PresentationModel() &#123; changeSupport = new PresentationModelChangeSupport(this); &#125; public String getHello() &#123; return name + &quot;: hello Android MVVM(Presentation Model)!&quot;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; Log.d(&quot;model&quot;, &quot;setName(),name: &quot; + name); &#125; public void sayHello()&#123; changeSupport.firePropertyChange(&quot;hello&quot;); &#125; @Override public PresentationModelChangeSupport getPresentationModelChangeSupport() &#123; return changeSupport; &#125;&#125; Controller层: 1234567891011121314public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); PresentationModel presentationModel = new PresentationModel(); ViewBinder viewBinder = createViewBinder(); View rootView = viewBinder.inflateAndBind(R.layout.activity_main, presentationModel);//将model和view进行绑定 setContentView(rootView); &#125; private ViewBinder createViewBinder() &#123; BinderFactory reusableBinderFactory = new BinderFactoryBuilder().build(); return reusableBinderFactory.createViewBinder(this); &#125;&#125; 从代码可以看出，Robobinding移除了如addXXListener(),findViewById()等代码，有点儿类似Annotation框架，精简了Activity结构，使得代码更容易阅读，维护，采用了源代码生成的方式来代替java反射，所以不会有反射额外的性能开销。 ##三、android 官方databinding使用android官方支持的databinding框架使用使用条件： android studio 1.3及以上版本 gradle 2.2及以上版本 android plugin for gradle 1.3.0及以上版本 使用步骤： 在项目顶层build.gradle中添加以下依赖： 1dependencies &#123; classpath &quot;com.android.databinding:dataBinder:1.0-rc1&quot;&#125; 在需要使用databinding的moudle中添加 1apply plugin: &apos;com.android.databinding&apos; 注意：在项目编译过程中，会出现诸如以下错误：错误一：1Error:Application and test application id cannot be the same: both are &apos;com.demo.mobile&apos; for qihuDebugAndroidTest 此处要求test的application id和项目id不能一致，需将test 的id（即testApplicationId “com.demo.mobile”修改为”com.demo.mobile.test”) 示例1:12345678910111213141516171819202122view 文件 activity_main.xml:&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;stu&quot; type=&quot;com.demo.mobile.databind.Student&quot; /&gt; //指明该view文件要绑定的数据模型 &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;stu.name&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;stu.addr&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Model文件：1234567891011121314package com.demo.mobile.databind;/** * Created by gaoge on 15/9/22. */public class Student &#123; private final String name; private final String addr; public Student(String name, String addr) &#123; this.name = name; this.addr = addr; &#125; public String getName() &#123; return name; &#125; public String getAddr() &#123;return this.addr; &#125;&#125; 绑定过程：TestDataBindingActivity 12345678public class TestDataBindingAct extends Activity&#123;@Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); ActivityMainBinding binding=DataBindingUtil.setContentView(this,R.layout.activity_main); binding.setStu(new Student(&quot;姓名&quot;, &quot;地址&quot;)); //将Model和view(xml文件进行绑定） &#125;&#125; 在mobile module 的build.gradle文件中声明 apply “com.android.databinding”后，android编译系统会自动根据xml文件名称”activity_main”生成一个ActivityMainBinding的class 文件(生成文件的命名格式和xml一一对应)但是项目中目前使用到google annotation注释框架，且apt的版本是1.4,会和databinding编译过程冲突，造成databinding不能自动生成ActivityBinding文件，需要在mobile module的build.gradle文件中，将classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.4&#39; 改为classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.7&#39;附apt和databinding冲突文章：https://bitbucket.org/hvisser/android-apt/issues/38/android-apt-breaks-brand-new-data-binding ##修改Model后自动更新UI##更改Model后自动更新UI，可以通过两种方法实现： 让Model实体继承自BaseObservable，并且对相应的属性的get()方法增加@Bindable注解，在set()方法中增加notifyPropertyChanged()属性，示例： 1234567891011121314public class Student extends BaseObservable &#123;private String name; public Student() &#123;&#125;public Student(String name) &#123;this.name = name; &#125;@Bindable public String getName() &#123;return name; &#125;public void setName(String name) &#123;this.name = name; notifyPropertyChanged(BR.name); &#125;&#125;` 对于Model属性，使用google 设计的支持监听的数据类型ObservableFields(包括ObservableField ，ObservableBoolean ,ObservableByte ,ObservableChar ,ObservableShort ,ObservableInt ,ObservableLong，ObservableArrayMap,ObservableArrayList) 12345public class People &#123; public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableInt age = new ObservableInt(); public ObservableBoolean isMan = new ObservableBoolean(); &#125;","tags":[{"name":"架构","slug":"架构","permalink":"http://www.jtsource.com/tags/架构/"}]},{"title":"Android Activity启动源码及其应用","date":"2017-03-25T04:44:41.000Z","path":"2017/03/25/Android-Activity启动源码及其应用/","text":"开发中经常遇到使用Activity ，网上关于讲解其原理的也很多，但是都是零零散散，今天想做个总结，并且也提高一下自己对源码的认识 Acitivity 启动过程 先看入口 最常用的Activity 启动过程是 12345678910111213141516171819@Overridepublic void startActivity(Intent intent) &#123; startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125; 其实我们也可以通过context.startActivity(next);来启动Activity ，由于Context是抽象类，Activity是Context子类，所以最后都会走到上一个方法。 显然，从上往下，最终都是由startActivityForResult来实现的 123456789101112131415161718192021222324252627282930313233343536373839public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123; if (mParent == null) &#123; //这里会启动新的Activity，核心功能都在mMainThread.getApplicationThread()中完成 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; //发送结果，即onActivityResult会被调用 mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; 我们一行一行看，该方法三个参数都是正常使用时用到的，我们直接看内部，先去判断 mParent 是否为空，这个mParent是什么呢，它其实是一个Activity 在Android 4.1以上，可以指定123456789101112```&lt;application ... &gt; ... &lt;activity android:name=&quot;com.example.myfirstapp.DisplayMessageActivity&quot; android:label=&quot;@string/title_activity_display_message&quot; android:parentActivityName=&quot;com.example.myfirstapp.MainActivity&quot; &gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;com.example.myfirstapp.MainActivity&quot; /&gt; &lt;/activity&gt;&lt;/application&gt; 一般的Activity其mParent为null，mParent常用在ActivityGroup中，ActivityGroup已废弃，而在ActivityGroup内部的Activity调用startActivity的时候也会走到上面，内部处理逻辑和上面是类似的 也就是说 启动新的Activity是在mInstrumentation.execStartActivity(this,mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);这个方法中，先不考虑mInstrumentation是做什么的，我们看内部实现12345678910111213141516171819202122232425262728293031323334public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; //核心功能在这个whoThread中完成，其内部scheduleLaunchActivity方法用于完成activity的打开 IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); // checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; 往里面看 contextThread 就是之前传入的mMainThread.getApplicationThread() 这个mMainThread 其实是一个Binder对象 对于Binder的原理请看 Android进程间通信（IPC）机制Binder简要介绍再回到刚才的源码，往下看，先在mActivityMonitors中查找一遍看是否存在这个activity，如果找到了就跳出循环，并且如果可以运行就返回监控器的结果。对于ActivityMonitor，其实是是google为了自动测试所添加的一个类，可以说是一个工具类，此处我们不深研究，若想了解请看ActivityMonitor 类的功能 接下来在try…catch 里就是真正打开activity的地方，核心功能在whoThread中完成 另外提一下intent);```这个方法就是专门抛异常的，它会对结果进行检查，如果无法打开activity，则抛出诸如ActivityNotFoundException类似的各种异常1如在xml中没有注册目标activity，Unable to find explicit activity class等 public static void checkStartActivityResult(int res, Object intent) { if (res &gt;= ActivityManager.START_SUCCESS) { return; } switch (res) { case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); } } 1接着上文看，在try...catch 中首先是要对传递的数据做准备 intent.migrateExtraStreamToClipData();intent.prepareToLeaveProcess();12345第一个是将intent里的bundle数据进行处理以便给底层处理，第二句准备离开应用程序进程，进入ActivityManagerService进程（意味着bundle的数据要在进程间传递）*关于Intent 的机制请看 [源码角度轻松学习Intent机制](http://www.jianshu.com/p/40ff93eff1a0)*再接下来就是我们要关注的重点了，也是真正打开activity的地方，核心功能在whoThread中完成。 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options); //这个方法是专门抛异常的，它会对结果进行检查，如果无法打开activity， //则抛出诸如ActivityNotFoundException类似的各种异常 checkStartActivityResult(result, intent); 12这里 ActivityManagerNative.getDefault() 返回的是一个IActivityManager接口的代理类， private static final Singleton gDefault = new Singleton() { protected IActivityManager create() { IBinder b = ServiceManager.getService(“activity”); if (false) { Log.v(“ActivityManager”, “default service binder = “ + b); } IActivityManager am = asInterface(b); if (false) { Log.v(“ActivityManager”, “default service = “ + am); } return am; } }; /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 12345678910这里我把方法提取了一下，也就是说返回的是一个ActivityManagerProxy对象的引用，其中```ServiceManager.getService(&quot;activity&quot;);``` 获取了一个系统级的service，而这个Service 实质上就是ActivityManagerService，这里就完成了一个对ActivityManagerService的代理对象ActivityManagerProxy的实例.&gt;总的来说这里使用的是设计模式中的[代理模式](https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/tree/master/proxy/singwhatiwanna), ActivityManagerProxy和ActivityManagerNative 都实现了IActivityManager，ActivityManagerProxy 就是代理部分，而ActivityManagerNative 就是真实部分，但ActivityManagerNative 是个抽象类，其并不处理过多的具体逻辑，大部分具体逻辑的实现由子类ActivityManagerService 承担，ActivityManagerService 是系统级的Service 并且运行于独立的进程中，而ActivityManagerProxy 也运行于自己的进程中，因此它们两个之间的通信必定是通过跨进程来进行的，也就是基于Android的Binder机制，Binder机制过于复杂。若想了解Binder机制请参考[[Binder架构解析](http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/#anchor1)](http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/)关于ActivityManger 请参考[ActivityManger架构解析](http://blog.csdn.net/caowenbin/article/details/6036726)![ActivityManger运行机制](http://upload-images.jianshu.io/upload_images/1212336-9a5c2a630b02f2ca.gif?imageMogr2/auto-orient/strip)也就是说最终是通过Binder IPC到ActivityManagerService所在进程调用ActivityManagerService的startActivity方法 @Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, userId, null, null); } 1234&gt;这个ActivityStackSupervisor类到底是个啥？如果仔细查阅，低版本的Android源码上是没有这个类的；后来AMS的代码进行了部分重构，关于Activity栈管理的部分单独提取出来成为了ActivityStackSupervisor类继续往里面看，其内部又调用了[startActivityLocked](http://androidxref.com/5.1.1_r6/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#startActivityLocked)方法，这个方法的作用是在startActivity 前做一系列的检查，如没有在Manifestfest中注册抛出的异常 if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) { // We couldn’t find the specific class specified in the Intent. // Also the end of the line. err = ActivityManager.START_CLASS_NOT_FOUND;}if (err != ActivityManager.START_SUCCESS) { if (resultRecord != null) { resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode, Activity.RESULT_CANCELED, null); } ActivityOptions.abort(options); return err;}123456789如果启动不成功就返回这个err，记得在之前mInstrumentation里有个checkStartActivityResult方法么，由它来处理这个信息，并抛出异常。&gt;activity 在 AMS 中的形式是 ActivityRecord,task 在 AMS 中的形式为TaskRecord,进程在 AMS 中的管理形式为 ProcessRecord这里还有会处理Activity 的LaunchMode 启动判断，请查看[Activity LaunchMode源码分析](http://www.jianshu.com/p/09365022adac)总结可以看下图![Activity 的启动过程 在ActivityStackSupervisor和ActivityStack 之间的传递顺序](http://upload-images.jianshu.io/upload_images/1212336-0093b93722c8af42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)从上图看出，最后走到了ActivityStackSupervisor中的realStartActivityLocked 方法,这个方法中有如下的代码 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);12345其中，app.thread的类型为IApplicationThread，IApplicationThread 是个接口，这个接口继承了IInterFace接口，所以它是一个Binder类型的接口，看到这个接口里的方法我们可以猜测这个接口的实现类完成了启动activity和service的相关功能，而我们要看其中的实现方法就要看它的实现类，还记得上面我们的ApplicationThreadNative么？它继承了IApplicationThread接口，其实他就是这个接口的实现类，进入这个类中我们看一下![ApplicationThread](http://upload-images.jianshu.io/upload_images/1212336-7d22225148fb3891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)总的来说饶了一圈，Activity的启动最终回到了ApplicationThread中，ApplicationThread是通过scheduleLaunchActivity 方法来启动Activity @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); } 12这里发送了一个启动Activity的消息交由Handler处理，这个Handler就是H，从sendMessage方法看出，它的作用就是发送一个消息给H处理，看一下H对消息的处理方法 public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; case RELAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; 12Handler H 对“LAUNCH_ACTIVITY” 这个消息处理看出，Activity启动是在handleLaunchActivity(r, null); 方法中实现的 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn&apos;t in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try { r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) { r.state = oldState; } if (!r.activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPause()&quot;); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to pause activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.paused = true; } } else { // If there was an error, for any reason, tell the activity // manager to stop us. try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { // Ignore } } } 12里面的performLaunchActivity 是真正实现activity的方法 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // System.out.println(“##### [“ + System.currentTimeMillis() + “] ActivityThread.performLaunchActivity(“ + r + “)”); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } //首先从intent中解析出目标activity的启动参数 ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //用ClassLoader（类加载器）将目标activity的类通过类名加载进来并调用newInstance来实例化一个对象 //其实就是通过Activity的无参构造方法来new一个对象，对象就是在这里new出来的。 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource() if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; //目标activity的onCreate被调用了，到此为止，Activity被启动了，接下来的流程就是Activity的生命周期了， //本文之前已经提到，其生命周期的各种状态的切换由ApplicationThread内部来完成 mInstrumentation.callActivityOnCreate(activity, r.state); if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } if (!r.activity.mFinished) { activity.mCalled = false; mInstrumentation.callActivityOnPostCreate(activity, r.state); if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPostCreate()&quot;); } } } r.paused = true; mActivities.put(r.token, r); } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); } } return activity; } 12这里面看到 Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( “Unable to instantiate activity “ + component + &quot;: &quot; + e.toString(), e); } } ```这个方法就是通过mInstrumentation.newActivity 方法，用classLoader创建activity的实例，这样就创建了Activity，再往下看就是创建Application，以及activity attach的回调方法。","tags":[{"name":"源码","slug":"源码","permalink":"http://www.jtsource.com/tags/源码/"}]},{"title":"Activity LaunchMode源码分析","date":"2017-03-25T04:44:41.000Z","path":"2017/03/25/Activity LaunchMode源码分析/","text":"之前一篇文章分析了Android Activity启动过程源码 这里单独拿出来一篇文章分析Activity 启动模式的源码 我们知道Activity的start是走到Instrumentation的execStartActivity方法中，而这里是调用了ActivityManagerNative的getDefault方法 来获得一个ActivityManagerService(以下简称AMS)的远程代理对象，要走到AMS的startActivity方法。123456int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, null, options);checkStartActivityResult(result, intent); 这里先解释一下startActivity方法里的一些参数 参数 作用 whoThread IApplicationThread的binder对象 用于AMS进行进程间通信 who 上下文对象 其实就是Activity intent 目标intent intent.resolveTypeIfneed 若没有在Manifest文件里面注明Activity的mime类型，返回null token Binder对象 通过它可以获得Activity的相关信息 后边会保存到sourceRecord这个对象里面 target 我们调用的Activity requestCode 若没有设置结果就是小于0 0 flags ProfilerInfo null options 是一个bunder对象，记录用intent传递的信息 这里对应着AMS 中startactivity的参数1234567891011121314151617181920@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, userId, null, null);&#125; 然后会调用ActivityStackSupervisor的startActivityMayWait方法而ActivityStackSupervisor 就是专门管理activity的堆栈的类 这里会先解析我们的intent来获取信息，通过调用函数resoleActivity方法获取ActivityInfo，这里主要是activity在AndroidManifest.xml里的信息 再往下看，进入到startActivityLocked 方法中 另提一下activity 在 AMS 中的形式是 ActivityRecord,task 在 AMS 中的形式为TaskRecord,进程在 AMS 中的管理形式为 ProcessRecord 我们发现这里有两个ActivityRecord对象 有sourceRecord 和resultRecord sourceRecord 代表的是最开始的activity这就是通过resultTo这个binder对象获得Mainactivity的相关信息然后保存到这个对象中resultRecord 代表的是接受启动结果的Activity因为requestcode==-1 所以这里resultRecord==null final int launchFlags = intent.getFlags();这里获取Intent的启动Flag 就是我们在Intent.setFlag里面设置的标志这个函数的主要作用就是处理sourceRecord和resultRecord两个对象在这里sourceRecord和resultRecord指向的应该是同一个activity 然后调用startActivityUncheckedLocked来处理本次的启动Activity的请求 从这里我们可以看到 获取了activity的launchModel ，也就是对launchModel的判断处理应该是在这里这里先判断是否FLAG_ACTIVITY_NEW_DOCUMENT，这个平时用的比较少，在android5.0上主要是决定你的task和activity是如何展现在overview screen 中的，详细请看Android 5.0 Overview Screen–总览画面再往下看 startFlags == 0 所以此时不会进入这个判断，没有设置这个FLAG_ACTIVITY_PREVIOUS_IS_TOP，所以我们的notTop==null接着 系统默认addingToTask= false 默认是开启新的Task，从后面的判断也可以看出来 之前说过 sourceRecord就是最开始的activity 所以它不会为null，这样就到了else 中 inTask = null； 在这里判断了启动模式，判断当前activity的启动模式和要启动的activity的启动模式，根据相应的启动模式设置launchFlags 这里目的是判断启动的activity是否在堆栈里存在，如果存在就直接在进行相应的操作在文章开头 resultRecord 默认为null而且requestCode假如没有设置的话，requestCode小于0，所以resultRecord没有被赋值，所以我们构造ActivityRecord 时传入的是null，也就是可以进入这个if判断里再往里看这里会判断启动的activity是否是SingleInstance，根据此进入不同的方法，目的是找到activity，如果有就返回，如果没有就返回null，先来看findTaskLocked方法 stack里的findTaskLocked方法比较长，顶部activity，如果没有就返回null，从注释上来看就是返回堆栈里的activity,简单说一下就是返回发起请求的activity，也是这个函数返回的activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 /** * Returns the top activity in any existing task matching the given * Intent. Returns null if no such task is found. */ ActivityRecord findTaskLocked(ActivityRecord target) &#123; Intent intent = target.intent; ActivityInfo info = target.info; ComponentName cls = intent.getComponent(); if (info.targetActivity != null) &#123; cls = new ComponentName(info.packageName, info.targetActivity); &#125; final int userId = UserHandle.getUserId(info.applicationInfo.uid); boolean isDocument = intent != null &amp; intent.isDocument(); // If documentData is non-null then it must match the existing task data. Uri documentData = isDocument ? intent.getData() : null; if (DEBUG_TASKS) Slog.d(TAG, &quot;Looking for task of &quot; + target + &quot; in &quot; + this); for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final TaskRecord task = mTaskHistory.get(taskNdx); if (task.voiceSession != null) &#123; // We never match voice sessions; those always run independently. if (DEBUG_TASKS) Slog.d(TAG, &quot;Skipping &quot; + task + &quot;: voice session&quot;); continue; &#125; if (task.userId != userId) &#123; // Looking for a different task. if (DEBUG_TASKS) Slog.d(TAG, &quot;Skipping &quot; + task + &quot;: different user&quot;); continue; &#125; final ActivityRecord r = task.getTopActivity(); if (r == null || r.finishing || r.userId != userId || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; if (DEBUG_TASKS) Slog.d(TAG, &quot;Skipping &quot; + task + &quot;: mismatch root &quot; + r); continue; &#125; final Intent taskIntent = task.intent; final Intent affinityIntent = task.affinityIntent; final boolean taskIsDocument; final Uri taskDocumentData; if (taskIntent != null &amp;&amp; taskIntent.isDocument()) &#123; taskIsDocument = true; taskDocumentData = taskIntent.getData(); &#125; else if (affinityIntent != null &amp;&amp; affinityIntent.isDocument()) &#123; taskIsDocument = true; taskDocumentData = affinityIntent.getData(); &#125; else &#123; taskIsDocument = false; taskDocumentData = null; &#125; if (DEBUG_TASKS) Slog.d(TAG, &quot;Comparing existing cls=&quot; + taskIntent.getComponent().flattenToShortString() + &quot;/aff=&quot; + r.task.rootAffinity + &quot; to new cls=&quot; + intent.getComponent().flattenToShortString() + &quot;/aff=&quot; + info.taskAffinity); if (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; task.rootAffinity != null) &#123; if (task.rootAffinity.equals(target.taskAffinity)) &#123; if (DEBUG_TASKS) Slog.d(TAG, &quot;Found matching affinity!&quot;); return r; &#125; &#125; else if (taskIntent != null &amp;&amp; taskIntent.getComponent() != null &amp;&amp; taskIntent.getComponent().compareTo(cls) == 0 &amp;&amp; Objects.equals(documentData, taskDocumentData)) &#123; if (DEBUG_TASKS) Slog.d(TAG, &quot;Found matching class!&quot;); //dump(); if (DEBUG_TASKS) Slog.d(TAG, &quot;For Intent &quot; + intent + &quot; bringing to top: &quot; + r.intent); return r; &#125; else if (affinityIntent != null &amp;&amp; affinityIntent.getComponent() != null &amp;&amp; affinityIntent.getComponent().compareTo(cls) == 0 &amp;&amp; Objects.equals(documentData, taskDocumentData)) &#123; if (DEBUG_TASKS) Slog.d(TAG, &quot;Found matching class!&quot;); //dump(); if (DEBUG_TASKS) Slog.d(TAG, &quot;For Intent &quot; + intent + &quot; bringing to top: &quot; + r.intent); return r; &#125; else if (DEBUG_TASKS) &#123; Slog.d(TAG, &quot;Not a match: &quot; + task); &#125; &#125; return null;&#125; 这里简单说一下，先是从mTaskHistory中遍历得到一个任务Task，并根据userid找到当前的task ，找到这个任务的顶部activity，并且保证它启动模式不是singleInstance，都满足了返回以下条件的activity 再回到刚才的方法往下看 这里先去activitystack里的moveToFront()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// If the caller has requested that the target task be// reset, then do so.if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);&#125;if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don&apos;t need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! And for paranoia, make // sure we have correctly resumed the top activity. if (doResume) &#123; resumeTopActivitiesLocked(targetStack, null, options); &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_RETURN_INTENT_TO_CALLER;&#125;if ((launchFlags &amp; (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) &#123; // The caller has requested to completely replace any // existing task with its new activity. Well that should // not be too hard... reuseTask = intentActivity.task; reuseTask.performClearTaskLocked(); reuseTask.setIntent(r);&#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || launchSingleInstance || launchSingleTask) &#123; // In this situation we want to remove all activities // from the task up to the one being started. In most // cases this means we are resetting the task to its // initial state. ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags); if (top != null) &#123; if (top.frontOfTask) &#123; // Activity aliases may mean we use different // intents for the top activity, so make sure // the task now has the identity of the new // intent. top.task.setIntent(r); &#125; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task); top.deliverNewIntentLocked(callingUid, r.intent); &#125; else &#123; // A special case: we need to // start the activity because it is not currently // running, and the caller has asked to clear the // current task to have this activity at the top. addingToTask = true; // Now pretend like this activity is being started // by the top of its task, so it is put in the // right place. sourceRecord = intentActivity; &#125;&#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123; // In this case the top activity on the task is the // same as the one being launched, so we take that // as a request to bring the task to the foreground. // If the top activity in the task is the root // activity, deliver this new intent to it if it // desires. if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop) &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, intentActivity.task); if (intentActivity.frontOfTask) &#123; intentActivity.task.setIntent(r); &#125; intentActivity.deliverNewIntentLocked(callingUid, r.intent); &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123; // In this case we are launching the root activity // of the task, but with a different intent. We // should start a new instance on top. addingToTask = true; sourceRecord = intentActivity; &#125;&#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123; // In this case an activity is being launched in to an // existing task, without resetting that task. This // is typically the situation of launching an activity // from a notification or shortcut. We want to place // the new activity on top of the current task. addingToTask = true; sourceRecord = intentActivity;&#125; else if (!intentActivity.task.rootWasReset) &#123; // In this case we are launching in to an existing task // that has not yet been started from its front door. // The current task has been brought to the front. // Ideally, we&apos;d probably like to place this new task // at the bottom of its stack, but that&apos;s a little hard // to do with the current organization of the code so // for now we&apos;ll just drop it. intentActivity.task.setIntent(r);&#125;if (!addingToTask &amp;&amp; reuseTask == null) &#123; // We didn&apos;t do anything... but it was needed (a.k.a., client // don&apos;t use that intent!) And for paranoia, make // sure we have correctly resumed the top activity. if (doResume) &#123; targetStack.resumeTopActivityLocked(null, options); &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_TASK_TO_FRONT;&#125; 这里主要看 这里走到了ActivityStack的performClearTaskLocked方法里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Perform clear operation as requested by * &#123;@link Intent#FLAG_ACTIVITY_CLEAR_TOP&#125;: search from the top of the * stack to the given task, then look for * an instance of that activity in the stack and, if found, finish all * activities on top of it and return the instance. * * @param newR Description of the new activity being started. * @return Returns the old activity that should be continued to be used, * or null if none was found. */ final ActivityRecord performClearTaskLocked(ActivityRecord newR, int launchFlags) &#123; int numActivities = mActivities.size(); for (int activityNdx = numActivities - 1; activityNdx &gt;= 0; --activityNdx) &#123; ActivityRecord r = mActivities.get(activityNdx); if (r.finishing) &#123; continue; &#125; if (r.realActivity.equals(newR.realActivity)) &#123; // Here it is! Now finish everything in front... final ActivityRecord ret = r; for (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) &#123; r = mActivities.get(activityNdx); if (r.finishing) &#123; continue; &#125; ActivityOptions opts = r.takeOptionsLocked(); if (opts != null) &#123; ret.updateOptionsLocked(opts); &#125; if (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, null, &quot;clear&quot;, false)) &#123; --activityNdx; --numActivities; &#125; &#125; // Finally, if this is a normal launch mode (that is, not // expecting onNewIntent()), then we will finish the current // instance of the activity so a new fresh one can be started. if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) &#123; if (!ret.finishing) &#123; stack.finishActivityLocked(ret, Activity.RESULT_CANCELED, null, &quot;clear&quot;, false); return null; &#125; &#125; return ret; &#125; &#125; return null; &#125; 这里就是根据ID找到等于参数taskId的任务，然后在这个任务中查找是否已经存在即将要启动的Activity的实例，如果存在，就会把这个Actvity实例上面直到任务堆栈顶端的Activity通过调用finishActivityLocked函数将它们结束掉。 在这里便引出了manifest文件中的一个重要属性，taskAffinity。在官方文档中可以得到关于taskAffinity的以下信息 taskAffinity表示当前activity具有亲和力的一个任务（原句为The task that the activity has an affinity for.），大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。 一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。 这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。（这个比较 难以理解，请结合中的属性allowTaskReparenting和Intent中的标志 FLAG_ACTIVITY_NEW_TASK加以理解） 默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。 回到前面的startActivityUncheckedLocked函数中，这里的变量top就为null了，于是执行下面的else语句 所以 此时将addintToTask=true 并且sourceRecord = 我们的activity，再往下看1234567891011121314151617181920212223242526272829303132333435363738394041if (r.packageName != null) &#123; // If the activity being launched is the same as the one currently // at the top, then we need to check if it should only be launched // once. ActivityStack topStack = getFocusedStack(); ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task); // For paranoia, make sure we have correctly // resumed the top activity. topStack.mLastPausedActivity = null; if (doResume) &#123; resumeTopActivitiesLocked(); &#125; ActivityOptions.abort(options); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don&apos;t need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; top.deliverNewIntentLocked(callingUid, r.intent); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125;&#125; else &#123; if (r.resultTo != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return ActivityManager.START_CLASS_NOT_FOUND;&#125; 根据注释我们能看出这个方法是检查当前任务的顶端是否是我们要启动的activity，接着往下看，便是启动activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 boolean newTask = false; boolean keepCurTransition = false; TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != null ? sourceRecord.task : null; // Should this be considered a new task? if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; if (isLockTaskModeViolation(reuseTask)) &#123; Slog.e(TAG, &quot;Attempted Lock Task Mode violation r=&quot; + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; newTask = true; targetStack = adjustStackFocus(r, newTask); if (!launchTaskBehind) &#123; targetStack.moveToFront(); &#125; if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, voiceSession, voiceInteractor, !launchTaskBehind /* toTop */), taskToAffiliate); if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r + &quot; in new task &quot; + r.task); &#125; else &#123; r.setTask(reuseTask, taskToAffiliate); &#125; if (!movedHome) &#123; if ((launchFlags &amp; (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) &#123; // Caller wants to appear on home activity, so before starting // their own activity we will bring home to the front. r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; &#125; &#125; else if (sourceRecord != null) &#123; final TaskRecord sourceTask = sourceRecord.task; if (isLockTaskModeViolation(sourceTask)) &#123; Slog.e(TAG, &quot;Attempted Lock Task Mode violation r=&quot; + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = sourceTask.stack; targetStack.moveToFront(); final TaskRecord topTask = targetStack.topTask(); if (topTask != sourceTask) &#123; targetStack.moveTaskToFrontLocked(sourceTask, r, options); &#125; else &#123; mWindowManager.moveTaskToTop(topTask.taskId); &#125; if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123; // In this case, we are adding the activity to an existing // task, but the caller has asked to clear that task if the // activity is already running. ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags); keepCurTransition = true; if (top != null) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task); top.deliverNewIntentLocked(callingUid, r.intent); // For paranoia, make sure we have correctly // resumed the top activity. targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; ActivityOptions.abort(options); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; // In this case, we are launching an activity in our own task // that may already be running somewhere in the history, and // we want to shuffle it to the front of the stack if so. final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r); if (top != null) &#123; final TaskRecord task = top.task; task.moveActivityToFrontLocked(top); ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task); top.updateOptionsLocked(options); top.deliverNewIntentLocked(callingUid, r.intent); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; // An existing activity is starting this new activity, so we want // to keep the new one in the same task as the one that is starting // it. r.setTask(sourceTask, null); if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r + &quot; in existing task &quot; + r.task + &quot; from source &quot; + sourceRecord); &#125; else if (inTask != null) &#123; // The calling is asking that the new activity be started in an explicit // task it has provided to us. if (isLockTaskModeViolation(inTask)) &#123; Slog.e(TAG, &quot;Attempted Lock Task Mode violation r=&quot; + r); return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = inTask.stack; targetStack.moveTaskToFrontLocked(inTask, r, options); targetStack.moveToFront(); mWindowManager.moveTaskToTop(inTask.taskId); // Check whether we should actually launch the new activity in to the task, // or just reuse the current activity on top. ActivityRecord top = inTask.getTopActivity(); if (top != null &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don&apos;t need to start a new activity, and // the client said not to do anything if that // is the case, so this is it! return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; top.deliverNewIntentLocked(callingUid, r.intent); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; if (!addingToTask) &#123; // We don&apos;t actually want to have this activity added to the task, so just // stop here but still tell the caller that we consumed the intent. ActivityOptions.abort(options); return ActivityManager.START_TASK_TO_FRONT; &#125; r.setTask(inTask, null); if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r + &quot; in explicit task &quot; + r.task); &#125; else &#123; // This not being started from an existing activity, and not part // of a new task... just put it in the top task, though these days // this case should never happen. targetStack = adjustStackFocus(r, newTask); targetStack.moveToFront(); ActivityRecord prev = targetStack.topActivity(); r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, null, null, true), null); mWindowManager.moveTaskToTop(r.task.taskId); if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r + &quot; in new guessed &quot; + r.task); &#125; mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked(), r.userId); if (sourceRecord != null &amp;&amp; sourceRecord.isRecentsActivity()) &#123; r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); &#125; if (newTask) &#123; EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId); &#125; ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) &#123; // Don&apos;t set focus on an activity that&apos;s going to the back. mService.setFocusedActivityLocked(r); &#125; return ActivityManager.START_SUCCESS;&#125; 首先将newTask变量初始化为false，表示不要在新的任务中启动Activity。由于前面的已经把addingToTask设置为true，因此，这里会执行中间的else if语句，即这里会把r.task设置为sourceRecord.task，即把即将启动的Activity放在原Activity所在的任务中启动。最后，就是调用startActivityLocked函数继续进行启动Activity的操作了","tags":[{"name":"源码","slug":"源码","permalink":"http://www.jtsource.com/tags/源码/"}]},{"title":"Android Gradle 编译总结","date":"2017-03-25T04:07:28.000Z","path":"2017/03/25/android-编译/","text":"Android Studio的编译时间非常长，提示一直在解决模块依赖，点击sync按钮同步第三方代码的时候也是巨慢,所以研究一下Androidstudio 编译过程 先说说gradle 的生命周期吧，gradle 构建一个工程主要分为三部分（完全掌握了下面这张图，整个 gradle 的构建过程能了解个十之七八了）： 初始化阶段：主要是解析 setting.gradle 文件（因此有人提到减少 setting.gradle 的 module 数量，是很有道理的，但是实际操作过程限制颇多，原因最后会大致说一下）； 读取配置阶段：主要是解析所有的 projects 下的 build.gradle 文件，包括 rootProject 和其他的 subprojects（子项目），检查语法，确定 tasks 依赖以建立 task 的有向无循环图，检查 task 里引用的文件目录是否存在等（这一步也进一步验证了减少 setting.gradle 里的 module 数量可以加快编译速度，因为减少一个 module ，需要解析的 build.gradle 文件就减少一个，第 3 步里就不会执行本属于这个 module 的任务了，但是还是 1 里面说的问题，限制颇多）； 阶段：按照 2 中建立的有向无循环图来执行每一个 task ，整个编译过程中，这一步基本会占去 9 成以上的时间，尤其是对于 Android 项目来讲，将 java 转为 class. compileDebugJavaWithJavac/compileReleaseJavaWithJavac 和将 class 合并成 dex transformClassesWithDexForDebug/transformClassesWithDexForRelease 这两步很耗时，第一步还好，第二步会耗时非常久。首先在 gradle.properties 里设置 org.gradle.jvmargs=-Xmx4096m //越大越好 然后在工程的 build.gradle 里的 android 结点下增加 dexOptions 配置，如下： dexOptions { dexInProcess true preDexLibraries true javaMaxHeapSize “4g”//越大越好 incremental true} 明确了 gradle 的生命周期，那么就可以看到加快编译速度的关键就是从第三步入手，当然，减少 setting.gradle 里的 modules 数量这一步也是必须的 在gradle中引用第三方模块时采用maven方式依赖，每次打开Android Studio或者点击sync按钮时，都会去maven中央仓库去取第三方的库文件,一般是jar或者aar文件,如果本地没有该文件，则下载回来，由于通过网络访问Android Studio默认的maven中央仓库jcenter很慢，因此就导致同步会非常耗时，尤其是第一次同步，或者clean后重新build的时候，一般都会在十分钟左右，即使库文件已经下载到本地了，也会去访问maven仓库的，因此当过多的通过maven方式依赖第三方库的时候Android Studio就会非常慢 ###解决办法 方法一： (1) 当第一次同步代码后，第三方库都下载到本地了，将gradle设置为offline模式，这样下次就不必访问网络了，这样同步速度从几分钟缩短到几秒钟，但缺点是一旦引入新的maven依赖，本地不存在这个库文件，还是得去访问网络，同样同步慢 方法二： (2) 自己搭建maven仓库，将常用的第三方库放在自己搭建的maven服务器上，这样访问内部的maven服务器就快多了，又方便分模块开发和打包，但这样对服务器的管理麻烦，技术含量高，比较适合需要分模块开发的大型项目，而且当多个模块开发不同步，需要对模块分版本进行依赖、打包、发布的时候，必须采用这种方式，例如：模块A已经开发完毕，模块B正在开发，但这个时候要发版本了，怎么办呢？解决办法就是依赖模块B的上个版本，也就是上个版本的aar文件 方法三： (3) 将第三方库下载到本地，然后将代码复制到自己的项目中，这种方法是在代码级别上直接使用别人的代码，优点是再也不用依赖别人的库，项目模块少，库与自己项目融为一体，缺点是复制的时候太辛苦了，不仅要复制代码文件，还要复制资源文件，容易出错，另外耦合比较严重，删除这个库的时候也非常麻烦，同时别人的代码也破坏了自己的代码风格和命名规范 方法四： (4) 推荐的方法是：尽量使用第三方库的jar、aar文件导入自己的项目，或者将第三方库下载到本地，然后当做一个本地模块导入自己的项目，不要再使用gradle中的maven依赖了这样就不用苦逼的去复制代码，删除的时候也很方便,只需删除模块即可，实现模块即插即用，缺点是会导致项目的模块太多，不美观，以及很多eclipse写的库导入Android Studio后还要自己修改才能编译通过，很多库是Android工程，不是标准意义的Android library,好在现在很多有名的库都专门提供了library，直接导入即可，还有Android Studio已经可以直接将eclipse工程当做一个module导入了,所以这种方法还是很简单的这种方法也就是以前eclipse使用第三方库的方法 上面讲到的几点，现有环境就可以做到的大概是这样（有一点要特别注意，如果工程里有交叉依赖，一定不要使用 –parallel 参数）： gradle assembleDebug –daemon –parallel -x lint -x test 如果是要直接安装到设备上的话，就把 assembleDebug 换成 installDebug ，assembleDebug 可以简写为 asD ，installDebug 可以简写为 iD","tags":[{"name":"编译","slug":"编译","permalink":"http://www.jtsource.com/tags/编译/"},{"name":"gradle","slug":"gradle","permalink":"http://www.jtsource.com/tags/gradle/"}]}]